= libi86 implementation notes

:back-link: (link:../README.asciidoc[↵])

== ``<dir.h>``

:fn-brown-00: footnote:brown-00[R. Brown et al.  Ralf Brown's Interrupt List, Jul 2000.  See in particular https://www.delorie.com/djgpp/doc/rbinter/ix/21/63.html.]

  * **``searchpath``, ``_searchpath``**: these functions support double-byte character sets (DBCS).  They should work properly on systems such as https://archive.org/details/microsoft-dos-v-5.0-v-japanese[MS-DOS 5.0/V (Japanese)] where file names might contain double-byte characters.
  ** Note that it is the OS _kernel_ that determines whether file names may use double-byte characters.  Because of this, I have implemented DBCS support for file names separately from the _userspace_ ``LC_*`` support in `<locale.h>`.
  ** `libi86` defines a function `_dos_get_dbcs_lead_table ()` which calls `int 0x21`, `%ax` =`0x6300`,{fn-brown-00} to obtain the DBCS lead byte table.   However, if the underlying C library already implements this function, `libi86` will use that implementation instead.  {back-link}

== ``<direct.h>``

  * **``_mkdir``, ``mkdir``**: ``libi86`` ignores any __mode__ argument that may be passed to these functions.
  ** It might initially seem useful to use the __mode__ to change a newly created directory's attributes, via the ``_dos_setfileattr`` mechanism.  MS-DOS does allow one to mark a directory "read-only"; however, during actual file operations, MS-DOS still allows one to remove a "read-only" directory, or even to change such a directory's contents.  Thus, honouring the __mode__ is not very useful.  {back-link}

== ``<dos.h>``

:fn-chen-20: footnote:chen-20[R. Chen.  Why does MS-DOS put an int 20h at byte 0 of the COM file program segment?  The Old New Thing, Mar 2020.  https://devblogs.microsoft.com/oldnewthing/20200309-00/?p=103547.]
:fn-necasek-11: footnote:necasek-11[M. Necasek.  Who needs the address wraparound, anyway?  OS/2 Museum, Sep 2011.  http://www.os2museum.com/wp/who-needs-the-address-wraparound-anyway/.]

  * **``bdos``**: For IA-16 GCC, there is a second implementation of `bdos (`...`)` which uses the ancient `call 5` syscall interface.  This implementation exists mainly for stress-testing DOS implementations, and is likely not useful for writing new programs.
  ** Use an `#assert` directive to enable this second `bdos`.  See `<dos.h>` for details.
  ** `call 5` is an alternate way to invoke MS-DOS syscalls, supported to allow better compatibility with CP/M programs.{fn-chen-20}{fn-necasek-11}  Instead of calling `int 0x21` with the syscall number in `%ah`, one does a near call to `PSP:5` with the syscall number in `%cl`.  Only syscalls `0x00`—`0x24` work.
  ** Note that MS-DOS's `call 5` may clobber `%al` before handing over to the actual syscall handling code.  This means that the third parameter to `bdos (`...`)` should be considered as ignored.  {back-link}

== ``<libi86/stdlib.h>``

  * **``_fullpath``, ``_makepath``, ``_splitpath``**: see link:#dirh[notes on ``searchpath`` and ``_searchpath``].  {back-link}
