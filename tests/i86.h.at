dnl Copyright (c) 2018--2020 TK Chia
dnl
dnl This file is free software; you can redistribute it and/or modify it
dnl under the terms of the GNU Lesser General Public License as published by
dnl the Free Software Foundation; either version 2 of the License, or
dnl (at your option) any later version.
dnl
dnl This program is distributed in the hope that it will be useful, but
dnl WITHOUT ANY WARRANTY; without even the implied warranty of
dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
dnl Lesser General Public License for more details.
dnl
dnl You should have received a copy of the GNU Lesser General Public License
dnl along with this program; see the file COPYING2.LIB.  If not see
dnl <http://www.gnu.org/licenses/>.

AT_BANNER([[<i86.h> tests]])

AT_SETUP([[FP_SEG, FP_OFF]])
AT_LIBI86_CHECK_CXX(dnl
[[#include <stdlib.h>
#include <i86.h>
#ifndef __cplusplus
# error
#endif
volatile int y = 2;
static unsigned get_ss (void)
{
  unsigned v;
  __asm volatile ("{movw %%ss, %0|mov %0, ss}" : "=r" (v));
  return v;
}
int
main (void)
{
  if (FP_SEG (&y) != get_ss ())
    abort ();
  if (FP_OFF (&y) != (unsigned) &y)
    abort ();
  return 0;
}]],[])
AT_LIBI86_CHECK(dnl
[[#include <stdlib.h>
#include <i86.h>
#ifndef __IA16_CMODEL_TINY__
volatile int __far x = 1;
volatile int __far *px = &x;
#endif
volatile int y = 2;
static unsigned get_cs (void)
{
  unsigned v;
  __asm volatile ("{movw %%cs, %0|mov %0, cs}" : "=r" (v));
  return v;
}
static unsigned get_ss (void)
{
  unsigned v;
  __asm volatile ("{movw %%ss, %0|mov %0, ss}" : "=r" (v));
  return v;
}
int main (void)
{
  if (FP_SEG (main) != get_cs ())
    abort ();
  if (FP_OFF (main) != (unsigned) main)
    abort ();
#ifndef __IA16_CMODEL_TINY__
  if (FP_SEG (&x) != (unsigned long) &x >> 16)
    abort ();
  if (FP_SEG (&x) != (unsigned long) px >> 16)
    abort ();
  if (FP_OFF (&x) != (unsigned) (unsigned long) &x)
    abort ();
  if (FP_OFF (&x) != (unsigned) (unsigned long) px)
    abort ();
#endif
  if (FP_SEG (&y) != get_ss ())
    abort ();
  if (FP_OFF (&y) != (unsigned) &y)
    abort ();
  return 0;
}]],[])
AT_CLEANUP

AT_SETUP([[segread]])
AT_LIBI86_CHECK(dnl
[[#include <stdlib.h>
#include <string.h>
#include <i86.h>
static unsigned get_cs (void)
{
  unsigned v;
  __asm volatile ("{movw %%cs, %0|mov %0, cs}" : "=r" (v));
  return v;
}
static unsigned get_ss (void)
{
  unsigned v;
  __asm volatile ("{movw %%ss, %0|mov %0, ss}" : "=r" (v));
  return v;
}
int main (void)
{
  struct SREGS sregs;
  memset (&sregs, 0xf6, sizeof (sregs));
  segread (&sregs);
#ifndef __IA16_CMODEL_IS_FAR_TEXT
  if (sregs.cs != get_cs ())
    abort ();
  if (sregs.cs != FP_SEG (main))
    abort ();
#endif
  if (sregs.ss != get_ss ())
    abort ();
  if (sregs.ss != FP_SEG (&sregs))
    abort ();
  return 0;
}]],[])
AT_CLEANUP

AT_SETUP([[int86]])
AT_LIBI86_CHECK(dnl
[[#include <i86.h>
#include <string.h>
int main (void)
{
  union REGS regs;
#ifdef __MSDOS__
  static char msg[] = "Hello from int86!\r\n$(ignore this part)\r\n";
  memset (&regs, 0xf6, sizeof (regs));
  regs.h.ah = 0x09;
  regs.w.dx = FP_OFF (msg);
  int86 (0x21, &regs, &regs);
#else
# error
#endif
  return 0;
}]],[[Hello from int86!
]])
AT_LIBI86_CHECK(dnl
[[#include <bios.h>
#include <i86.h>
#include <stdlib.h>
#include <string.h>
int main (void)
{
  union REGS regs;
  memset (&regs, 0xf6, sizeof (regs));
  unsigned rv = (unsigned) int86 (0x12, &regs, &regs);
  if (rv != regs.w.ax)
    abort ();
  if (rv != _bios_memsize ())
    abort ();
  memset (&regs, 0xf6, sizeof (regs));
  rv = (unsigned) int86 (0x11, &regs, &regs);
  if (rv != regs.w.ax)
    abort ();
  if (rv != _bios_equiplist ())
    abort ();
  return 0;
}]],[])
AT_CLEANUP

AT_SETUP([[int86x]])
AT_LIBI86_CHECK_FOR_NONDPMIABLE(dnl
[[#include <stdlib.h>
#include <i86.h>
#include <string.h>
int main (void)
{
  union REGS regs;
  struct SREGS sregs;
#ifdef __MSDOS__
  static char msg[] = "Hello from int86x!\r\n$(ignore this part)\r\n";
  memset (&regs, 0xf6, sizeof (regs));
  memset (&sregs, 0xf6, sizeof (sregs));
  sregs.ds = FP_SEG (msg);
  regs.h.ah = 0x09;
  regs.w.dx = FP_OFF (msg);
  int86x (0x21, &regs, &regs, &sregs);
# ifndef __IA16_CMODEL_IS_FAR_TEXT
  if (sregs.cs != FP_SEG (main))
    abort ();
# endif
  if (sregs.ds != FP_SEG (msg))
    abort ();
  if (sregs.es != 0xf6f6u)
    abort ();
  if (sregs.ss != FP_SEG (&regs))
    abort ();
#else
# error
#endif
  return 0;
}]],[[Hello from int86x!
]])
AT_LIBI86_CHECK_FOR_SMALL_MODEL_OR_ABOVE_NONDPMIABLE(dnl
[[#include <stdlib.h>
#include <string.h>
#include <i86.h>
int main (void)
{
  union REGS regs;
  struct SREGS sregs;
#ifdef __MSDOS__
  static char __far msg[] = "Hello again!\r\n$(ignore this part)\r\n";
  memset (&regs, 0xf6, sizeof (regs));
  memset (&sregs, 0xf6, sizeof (sregs));
  sregs.ds = FP_SEG (msg);
  regs.h.ah = 0x09;
  regs.w.dx = FP_OFF (msg);
  int86x (0x21, &regs, &regs, &sregs);
# ifndef __IA16_CMODEL_IS_FAR_TEXT
  if (sregs.cs != FP_SEG (main))
    abort ();
# endif
  if (sregs.ds != FP_SEG (msg))
    abort ();
  if (sregs.es != 0xf6f6u)
    abort ();
  if (sregs.ss != FP_SEG (&regs))
    abort ();
#else
# error
#endif
  return 0;
}]],[[Hello again!
]])
AT_LIBI86_CHECK_FOR_NONDPMIABLE(dnl
[[#include <bios.h>
#include <i86.h>
#include <stdlib.h>
#include <string.h>
int main (void)
{
  union REGS regs;
  struct SREGS sregs;
  memset (&regs, 0xf6, sizeof (regs));
  memset (&sregs, 0xf6, sizeof (sregs));
  unsigned rv = (unsigned) int86x (0x12, &regs, &regs, &sregs);
  if (rv != regs.w.ax)
    abort ();
  if (rv != _bios_memsize ())
    abort ();
  if (sregs.ds != 0xf6f6u)
    abort ();
  if (sregs.es != 0xf6f6u)
    abort ();
  memset (&regs, 0xf6, sizeof (regs));
  memset (&sregs, 0xf6, sizeof (sregs));
  rv = (unsigned) int86x (0x11, &regs, &regs, &sregs);
  if (rv != regs.w.ax)
    abort ();
  if (rv != _bios_equiplist ())
    abort ();
  if (sregs.ds != 0xf6f6u)
    abort ();
  if (sregs.es != 0xf6f6u)
    abort ();
  return 0;
}]],[])
AT_CLEANUP

AT_SETUP([[intr]])
AT_LIBI86_CHECK_FOR_NONDPMIABLE(dnl
[[#include <i86.h>
#include <stdlib.h>
#include <string.h>
int main (void)
{
  union REGPACK regs;
#ifdef __MSDOS__
  static char msg[] = "Hello from intr!\r\n$(ignore this part)\r\n";
  memset (&regs, 0xf6, sizeof (regs));
  regs.h.ah = 0x09;
  regs.w.dx = FP_OFF (msg);
  regs.w.ds = FP_SEG (msg);
  intr (0x21, &regs);
  if (regs.w.ds != FP_SEG (msg))
    abort ();
  if (regs.w.es != 0xf6f6u)
    abort ();
#else
# error
#endif
  return 0;
}]],[[Hello from intr!
]])
AT_LIBI86_CHECK_FOR_SMALL_MODEL_OR_ABOVE_NONDPMIABLE(dnl
[[#include <i86.h>
#include <stdlib.h>
#include <string.h>
int main (void)
{
  union REGPACK regs;
#ifdef __MSDOS__
  static char __far msg[] = "Hello from intr...\r\n$(ignore this part)\r\n";
  memset (&regs, 0xf6, sizeof (regs));
  regs.h.ah = 0x09;
  regs.w.dx = FP_OFF (msg);
  regs.w.ds = FP_SEG (msg);
  intr (0x21, &regs);
  if (regs.w.ds != FP_SEG (msg))
    abort ();
  if (regs.w.es != 0xf6f6u)
    abort ();
#else
# error
#endif
  return 0;
}]],[[Hello from intr...
]])
AT_LIBI86_CHECK_FOR_NONDPMIABLE(dnl
[[#include <bios.h>
#include <i86.h>
#include <stdlib.h>
#include <string.h>
int main (void)
{
  union REGPACK regs;
  memset (&regs, 0xf6, sizeof (regs));
  intr (0x12, &regs);
  if (regs.w.ax != _bios_memsize ())
    abort ();
  if (regs.w.ds != 0xf6f6u)
    abort ();
  if (regs.w.es != 0xf6f6u)
    abort ();
  memset (&regs, 0xf6, sizeof (regs));
  intr (0x11, &regs);
  if (regs.w.ax != _bios_equiplist ())
    abort ();
  if (regs.w.ds != 0xf6f6u)
    abort ();
  if (regs.w.es != 0xf6f6u)
    abort ();
  return 0;
}]],[])
AT_CLEANUP

AT_SETUP([[_disable, _enable]])
AT_LIBI86_CHECK(dnl
[[#include <i86.h>
#include <stdlib.h>

static unsigned ticks (void)
{
  return *(unsigned volatile __far *) 0x0040006cul;
}

#ifndef __IA16_FEATURE_PROTECTED_MODE
static unsigned flags (void)
{
  unsigned f;
  __asm volatile ("pushf{w}; pop{w} %0" : "=g" (f) : : "memory");
  return f;
}
#endif

static void do_abort (void)
{
  _enable ();
  abort ();
}

int
main (void)
{
  unsigned from, c1, c2;

#ifndef __IA16_FEATURE_PROTECTED_MODE
  if (! (flags () & 0x0200u))
    abort ();
#endif

  srand (ticks ());
  c1 = 5000;
  while (c1-- != 0)
    {
      _disable ();

      /* Check that the handler for the timer interrupt (IRQ 0) cannot
	 update the tick count, when all IRQs are disabled.  */
      from = ticks ();
#ifndef __IA16_FEATURE_PROTECTED_MODE
      if (flags () & 0x0200u)
	do_abort ();
#endif
      c2 = rand() / (RAND_MAX / 100) + 1;
      while (c2-- != 0)
	{
	  if (ticks () != from)
	    do_abort ();
        }

#ifndef __IA16_FEATURE_PROTECTED_MODE
      if (flags () & 0x0200u)
	do_abort ();
#endif

      /* Allow interrupts for a while.  Every now and then, also wait for
	 the timer tick count to get updated.  */
      _enable ();
      if (c1 % 200 == 0)
	while (ticks () == from)
	  {
#ifndef __IA16_FEATURE_PROTECTED_MODE
	    __asm volatile ("hlt");
#else
	    unsigned ax;
	    __asm volatile ("int {$}0x2f" : "=a" (ax) : "0" (0x1680u) : "cc");
#endif
	  }
#ifndef __IA16_FEATURE_PROTECTED_MODE
      if (! (flags () & 0x0200u))
	do_abort ();
#endif
    }

  return 0;
}
]],[])
AT_CLEANUP
