dnl Copyright (c) 2018--2019 TK Chia
dnl
dnl This file is free software; you can redistribute it and/or modify it
dnl under the terms of the GNU Lesser General Public License as published by
dnl the Free Software Foundation; either version 2 of the License, or
dnl (at your option) any later version.
dnl
dnl This program is distributed in the hope that it will be useful, but
dnl WITHOUT ANY WARRANTY; without even the implied warranty of
dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
dnl Lesser General Public License for more details.
dnl
dnl You should have received a copy of the GNU Lesser General Public License
dnl along with this program; see the file COPYING2.LIB.  If not see
dnl <http://www.gnu.org/licenses/>.

AT_BANNER([[<dos.h> tests]])

AT_SETUP([[bdos, bdosptr]])
AT_LIBI86_CHECK(dnl
[[#include <dos.h>
int
main (void)
{
#ifdef __MSDOS__
  bdosptr (9, "Hello $(ignore this)", 0);
  bdos (2, '$', 0);
  bdos (2, 'f', 0);
  bdos (2, 'r', 0);
  bdos (2, 'o', 0);
  bdos (2, 'm', 0);
  bdos (2, '$', 0);
  bdosptr (9, " bdos and bdosptr!\r\n$(and ignore this too)", 0);
#else
# error
#endif
  return 0;
}]],[[Hello $from$ bdos and bdosptr!
]])
AT_CLEANUP

AT_SETUP([[intdos]])
AT_LIBI86_CHECK(dnl
[[#include <dos.h>
void abort (void);
int
main (void)
{
  union REGS regs;
  int rv;
#ifdef __MSDOS__
  memset (&regs, 0xf6, sizeof (regs));
  regs.h.ah = 0x02;
  regs.h.dl = 'y';
  intdos (&regs, &regs);
  write (1, "o\r\n", 3);
  return 0;
#else
# error
#endif
}]],[[yo
]])
AT_LIBI86_CHECK_FOR_NEAR_DATA_MODEL_NONDPMIABLE(dnl
[[#include <dos.h>
void abort (void);
int
main (void)
{
  union REGS regs;
  int rv;
#ifdef __MSDOS__
  static char msg[] = "Hello from intdos!\r\n(ignore this part)";
  memset (&regs, 0xf6, sizeof (regs));
  regs.h.ah = 0x40;
  regs.w.bx = 1;
  regs.w.cx = 20;
  regs.w.dx = FP_OFF (msg);
  rv = intdos (&regs, &regs);
  if (rv != 20 || regs.w.cflag)
    abort ();
  return 0;
#else
# error
#endif
}]],[[Hello from intdos!
]])
AT_CLEANUP

AT_SETUP([[intdosx]])
AT_LIBI86_CHECK(dnl
[[#include <dos.h>
#include <unistd.h>
void abort (void);
static unsigned
get_cs (void)
{
  unsigned v;
  __asm volatile ("{movw %%cs, %0|mov %0, cs}" : "=r" (v));
  return v;
}
static unsigned
get_ss (void)
{
  unsigned v;
  __asm volatile ("{movw %%ss, %0|mov %0, ss}" : "=r" (v));
  return v;
}
int
main (void)
{
  union REGS r;
  struct SREGS sr;
#ifdef __MSDOS__
  memset (&r, 0xf6, sizeof (r));
  memset (&sr, 0xf6, sizeof (sr));
  sr.ds = 1;
  sr.es = 2;
  r.h.ah = 0x02;
  r.h.dl = 'y';
  intdosx (&r, &r, &sr);
  if ((sr.ds & ~3u) != 0 || (sr.es & ~3u) != 0
# ifndef __IA16_CMODEL_IS_FAR_TEXT
      || sr.cs != get_cs ()
# endif
      || sr.ss != get_ss ())
    abort ();
  write (1, "o\r\n", 3);
  return 0;
#else
# error
#endif
}]],[[yo
]])
AT_LIBI86_CHECK_FOR_SMALL_MODEL_OR_ABOVE_NONDPMIABLE(dnl
[[#include <dos.h>
#include <string.h>
#include <time.h>
#ifndef __MSDOS__
# error
#endif
void abort (void);
__far const char msg1[] = "hello world",
		 msg2[] = "s\r\nso I put a ",
		 msg3[] = " in your ";
static unsigned
get_cs (void)
{
  unsigned v;
  __asm volatile ("{movw %%cs, %0|mov %0, cs}" : "=r" (v));
  return v;
}
static unsigned
get_ss (void)
{
  unsigned v;
  __asm volatile ("{movw %%ss, %0|mov %0, ss}" : "=r" (v));
  return v;
}
static void
hw (void)
{
  union REGS r;
  struct SREGS sr;
  unsigned cookie = time (NULL);
  memset (&r, 0xf6, sizeof (r));
  memset (&sr, 0xf6, sizeof (sr));
  r.h.ah = 0x40;
  r.w.bx = 1;
  r.w.cx = sizeof (msg1) - 1;
  r.w.dx = FP_OFF (msg1);
  sr.ds = FP_SEG (msg1);
  sr.es = cookie;
  if (intdosx (&r, &r, &sr) != sizeof (msg1) - 1
      || r.w.ax != sizeof (msg1) - 1 || r.w.cflag
# ifndef __IA16_CMODEL_IS_FAR_TEXT
      || sr.cs != get_cs ()
# endif
      || sr.ss != get_ss () || sr.ds != FP_SEG (msg1) || sr.es != cookie)
    abort ();
}
int
main (void)
{
  static __far const char msg4[] = "yo dawg I herd you like ",
			  msg5[] = "\r\nso you can $",
			  msg6[] = " while you ";
  const char __far *p;
  union REGS inr, outr;
  struct SREGS sr;
  memset (&inr, 0xf6, sizeof (inr));
  memset (&outr, 0xf6, sizeof (outr));
  memset (&sr, 0xf6, sizeof (sr));
  for (p = msg4; *p; ++p)
    bdos (2, *p, 0);
  hw ();
  inr.h.ah = 0x40;
  inr.w.bx = 1;
  inr.w.cx = sizeof (msg2) - 1;
  inr.w.dx = FP_OFF (msg2);
  sr.ds = FP_SEG (msg2);
  if (intdosx (&inr, &outr, &sr) != sizeof (msg2) - 1
      || outr.w.ax != sizeof (msg2) - 1 || outr.w.cflag)
    abort ();
  hw ();
  inr.w.cx = sizeof (msg3) - 1;
  inr.w.dx = FP_OFF (msg3);
  sr.ds = FP_SEG (msg3);
  if (intdosx (&inr, &outr, &sr) != sizeof (msg3) - 1
      || outr.w.ax != sizeof (msg3) - 1 || outr.w.cflag)
    abort ();
  hw ();
  inr.h.ah = 9;
  inr.w.dx = FP_OFF (msg5);
  sr.ds = FP_SEG (msg5);
  intdosx (&inr, &outr, &sr);
  hw ();
  inr.w.ax = 0x351a;
  intdosx (&inr, &outr, &sr);
  if (MK_FP (sr.es, outr.w.bx)
      != * (void __far * __far *) (unsigned long) (4 * 0x1a))
    abort ();
  for (p = msg6; *p; ++p)
    {
      inr.h.ah = 2;
      inr.h.dl = *p;
      memset (&sr, 0xf6, sizeof (sr));
      intdosx (&inr, &outr, &sr);
    }
  hw ();
  inr.h.ah = 0x40;
  inr.w.bx = 1;
  inr.w.cx = 2;
  inr.w.dx = FP_OFF (msg5);
  sr.ds = FP_SEG (msg5);
  if (intdosx (&inr, &outr, &sr) != 2 || outr.w.ax != 2 || outr.w.cflag)
    abort ();
  return 0;
}]],[[yo dawg I herd you like hello worlds
so I put a hello world in your hello world
so you can hello world while you hello world
]])
AT_CLEANUP

AT_SETUP([[_dos_close]])
AT_LIBI86_CHECK(dnl
[[#include <dos.h>
#include <errno.h>
void abort (void);
int main (int argc, char **argv)
{
  /* Try to close the stdin file descriptor.  This should succeed.  */
  if (_dos_close (0) != 0)
    abort ();

  /* Try to close the same file descriptor again.  This should fail.  */
  if (_dos_close (0) != EBADF)
    abort ();

  return 0;
}]],[[]])
AT_CLEANUP

AT_SETUP([[_dos_getdrive, _getdrive, _dos_setdrive]])
AT_LIBI86_CHECK(dnl
[[#include <dos.h>
void abort (void);
int
main (void)
{
  unsigned drive = 0xf6f6u, total = 0xf6f6, new_drive, new_total = 0xf6f6;
  _dos_getdrive (&drive);
  if (drive < 1 || drive > 0xff)
    abort ();
  if (drive != _getdrive ())
    abort ();
  _dos_setdrive (drive, &total);
  if (total < drive || total > 0xff)
    abort ();
  if (_getdrive () != drive)
    abort ();
  _dos_setdrive (0, &new_total);  /* this should do nothing */
  if (new_total != total)
    abort ();
  if (_getdrive () != drive)
    abort ();
  new_total = 0xf6f6;
  _dos_setdrive (total + 1, &new_total);  /* this should also do nothing */
  if (new_total != total)
    abort ();
  if (_getdrive () != drive)
    abort ();
  new_total = 0xf6f6;
  _dos_setdrive (drive + 0x100, &new_total);  /* this should also do nothing */
  if (new_total != total)
    abort ();
  if (_getdrive () != drive)
    abort ();
  for (new_drive = 1; new_drive <= drive; ++new_drive)
    {
      new_total = 0xf6f6;
      _dos_setdrive (new_drive, &new_total);  /* this should do something */
      if (new_total != total)
	abort ();
      if (_getdrive () != new_drive)
	abort ();
    }
  return 0;
}]],[[]])
AT_CLEANUP

AT_SETUP([[_dos_getfileattr]])
AT_LIBI86_CHECK(dnl
[[#include <dos.h>
#include <errno.h>
#include <stdio.h>
void abort (void);
int
main (int argc, char **argv)
{
  unsigned attr1 = 0xccccu, attr2 = 0xe5e5u, attr3 = 0xf6f6u;
#ifdef __MSDOS__
  errno = 0;

  if (_dos_getfileattr (argv[0], &attr1) != 0)
    abort ();
  puts ("1 OK");
  if (errno)
    abort ();
  puts ("2 OK");
  if ((attr1 & (_A_VOLID | _A_SUBDIR)) != 0)
    abort ();
  puts ("3 OK");

  if (_dos_getfileattr (".", &attr2) != 0)
    abort ();
  puts ("4 OK");
  if (errno)
    abort ();
  puts ("5 OK");
  if ((attr2 & (_A_VOLID | _A_SUBDIR)) != _A_SUBDIR)
    abort ();
  puts ("6 OK");

  if (_dos_getfileattr ("nul", &attr3) != ENOENT)
    abort ();
  puts ("7 OK");
  if (errno != ENOENT)
    abort ();
  puts ("8 OK");

  return 0;
#else
# error
#endif
}]],[[1 OK
2 OK
3 OK
4 OK
5 OK
6 OK
7 OK
8 OK
]])
AT_CLEANUP

AT_SETUP([[_dos_setfileattr]])
AT_LIBI86_CHECK(dnl
[[#include <dos.h>
#include <errno.h>
#include <stdio.h>
void abort (void);
int
main (int argc, char **argv)
{
  unsigned new_attr = 0;
#ifdef __MSDOS__
  errno = 0;

  if (_dos_setfileattr (argv[0], _A_RDONLY) != 0)
    abort ();
  puts ("1 OK");
  if (errno)
    abort ();
  puts ("2 OK");

  if (_dos_getfileattr (argv[0], &new_attr) != 0)
    abort ();
  puts ("3 OK");
  if ((new_attr & _A_RDONLY) == 0)
    abort ();
  puts ("4 OK");
  if ((new_attr & (_A_SUBDIR | _A_VOLID)) != 0)
    abort ();
  puts ("5 OK");

  switch (_dos_setfileattr ("nul", _A_RDONLY))
    {
      /*
       * MS-DOS says "Access denied" if a program tries to change the
       * attributes of the "nul" device file, while FreeDOS says "File not
       * found".
       */
    case ENOENT:
    case EACCES:
      break;
    default:
      abort ();
    }
  puts ("6 OK");
  if (errno != ENOENT && errno != EACCES)
    abort ();
  puts ("7 OK");

  return 0;
#else
# error
#endif
}]],[[1 OK
2 OK
3 OK
4 OK
5 OK
6 OK
7 OK
]])
AT_CLEANUP

AT_SETUP([[_dos_allocmem, _dos_freemem]])
AT_LIBI86_CHECK(dnl
[[#include <dos.h>
#include <errno.h>
#include <stdio.h>
void abort (void);
int
main (int argc, char **argv)
{
  unsigned max_paras = 0, seg = 0, i;
  unsigned long __far *ptr = 0;
#ifdef __MSDOS__
  errno = 0;
  if (_dos_allocmem (0xffffu, &max_paras) != ENOMEM)
    abort ();
  puts ("1 OK");
  if (errno != ENOMEM)
    abort ();
  puts ("2 OK");
  if (! max_paras)
    abort ();
  puts ("3 OK");

  errno = 0;
  if (_dos_allocmem (max_paras, &seg) != 0)
    abort ();
  puts ("4 OK");
  if (errno)
    abort ();
  puts ("5 OK");
  if (! seg)
    abort ();
  puts ("6 OK");

  ptr = MK_FP (seg, 0);
  i = max_paras;
  if (i > 0x1000)
    i = 0x1000;
  while (i-- != 0)
    {
      *ptr++ = 0xf6f6f6f6ul;  *ptr++ = 0xf6f6f6f6ul;
      *ptr++ = 0xf6f6f6f6ul;  *ptr++ = 0xf6f6f6f6ul;
    }

#ifndef __IA16_FEATURE_PROTECTED_MODE
  if (max_paras > 0x1000)
    {
      ptr = MK_FP (seg + max_paras - 0x1000, 0);
      i = 0x1000;
      while (i-- != 0)
	{
	  *ptr++ = 0xf6f6f6f6ul;  *ptr++ = 0xf6f6f6f6ul;
	  *ptr++ = 0xf6f6f6f6ul;  *ptr++ = 0xf6f6f6f6ul;
	}
    }
#endif

  errno = 0;
  if (_dos_freemem (seg) != 0)
    abort ();
  puts ("7 OK");
  if (errno)
    abort ();
  puts ("8 OK");

  return 0;
#else
# error
#endif
}]],[[1 OK
2 OK
3 OK
4 OK
5 OK
6 OK
7 OK
8 OK
]])
AT_CLEANUP

AT_SETUP([[_dos_findfirst, _dos_findnext, _dos_findclose]])
AT_LIBI86_CHECK(dnl
[[#include <dos.h>
#include <errno.h>
#include <string.h>
void abort (void);
int
main (int argc, char **argv)
{
#ifdef __MSDOS__
  struct find_t find;
  memset (&find, 0xf6, sizeof find);
  /* This program should be able to find itself, exactly once... */
  if (_dos_findfirst (argv[0], _A_HIDDEN | _A_SYSTEM, &find) != 0)
    abort ();
  if ((find.attrib & (_A_VOLID | _A_SUBDIR)) != 0)
    abort ();
  if (_dos_findnext (&find) != 18)  /* "no more files" */
    abort ();
  if (_dos_findclose (&find) != 0)
    abort ();
  return 0;
#else
# error
#endif
}]],[[]])
AT_CLEANUP
