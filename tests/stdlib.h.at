dnl Copyright (c) 2019--2021 TK Chia
dnl
dnl This file is free software; you can redistribute it and/or modify it
dnl under the terms of the GNU Lesser General Public License as published by
dnl the Free Software Foundation; either version 2 of the License, or
dnl (at your option) any later version.
dnl
dnl This program is distributed in the hope that it will be useful, but
dnl WITHOUT ANY WARRANTY; without even the implied warranty of
dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
dnl Lesser General Public License for more details.
dnl
dnl You should have received a copy of the GNU Lesser General Public License
dnl along with this program; see the file COPYING2.LIB.  If not see
dnl <http://www.gnu.org/licenses/>.

AT_BANNER([[<libi86/stdlib.h> tests]])

AT_SETUP([[_psp]])
AT_LIBI86_CHECK(dnl
[[#include <i86.h>
#include <stdlib.h>
#include <libi86/stdlib.h>
int
main (void)
{
#ifdef __MSDOS__
unsigned __far *psp_mem = MK_FP (_psp, 0);
  if (psp_mem[0] != 0x20cdu)
    abort ();
  return 0;
#else
# error
#endif
}]],[[]])
AT_CLEANUP

AT_SETUP([[_osmajor, _osminor]])
AT_LIBI86_CHECK(dnl
[[#include <i86.h>
#include <stdlib.h>
#include <libi86/stdlib.h>
int
main (void)
{
#ifdef __MSDOS__
  if (_osmajor < 2)
    abort ();
  if (_osminor > 99)
    abort ();
  return 0;
#else
# error
#endif
}]],[[]])
AT_CLEANUP

AT_SETUP([[_makepath]])
AT_LIBI86_CHECK(dnl
[[#include <errno.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <libi86/stdlib.h>
#include <string.h>
static void
check (unsigned test_num, bool should_error_p, const char *good_path,
       const char *drv, const char *dir, const char *fname, const char *ext)
{
  char path[_MAX_PATH];
  int res;
  memset (path, 0xf6, sizeof path);
  res = _makepath (path, drv, dir, fname, ext);
  if (should_error_p)
    {
      if (! res)
	abort ();
      /* path[] should be a valid string with a null terminator somewhere. */
      if (! memchr (path, 0, _MAX_PATH))
	abort ();
    }
  else
    {
      if (res)
	abort ();
      /* path[] should be the same as good_path[] (modulo letter case). */
      if (strcasecmp (path, good_path) != 0)
	abort ();
    }
  printf ("%u OK\n", test_num);
}
int
main (void)
{
#ifdef __MSDOS__
  char badness[_MAX_PATH];
  memset (badness, 0xf6, sizeof badness);
  check (1,  false, "\\", NULL, "\\", NULL, NULL);
  check (2,  false, "/", NULL, "/", NULL, NULL);
  check (3,  false, "foo", NULL, NULL, "foo", NULL);
  check (4,  false, "foo.", NULL, NULL, "Foo", ".");
  check (5,  false, "foo.bar", NULL, NULL, "foO", ".bAr");
  check (6,  false, "foo.bar", NULL, NULL, "fOo", "Bar");
  check (7,  false, "foo.bar/baz", NULL, "foo.Bar/", "baz", NULL);
  check (8,  false, "foo.bar\\baz", NULL, "foo.bar\\", "BAZ", NULL);
  check (9,  false, "foo.bar\\baz", NULL, "foo.bar", "BAZ", NULL);
  check (10, false, "\\foo.bar\\ba?z", NULL, "\\foo.Bar", "ba?z", NULL);
  check (11, false, "/foo.bar/ba?z", NULL, "/foo.bar", "BA?Z", NULL);
  check (12, false, "\\foo.Bar/*.*", NULL, "\\foo.bar/", "*", "*");
  check (13, false, "/foo.bar\\*.*", NULL, "/foo.bar\\", "*", ".*");
  check (14, false, "\\foo/Bar/*.*", NULL, "\\foo/bar/", "*", "*");
  check (15, false, "/foo\\bar\\*.*", NULL, "/foo\\bar\\", "*", ".*");
  check (16, false, "a:\\", "a:", "\\", NULL, NULL);
  check (17, false, "b:/", "B", "/", NULL, NULL);
  check (18, true, NULL, "?", NULL, NULL, NULL);
  check (19, true, NULL, "\\\\volume\\", NULL, NULL, NULL);
  check (20, true, NULL, "//volume/", NULL, NULL, NULL);
  check (21, false, "y:/foo\\bar/baz.qux/quux*.q?u",
		    "y:", "/foo\\bar/baz.qux", "quux*", "q?u");
  check (22, true, NULL, badness, badness, badness, badness);
  check (23, true, NULL, NULL, badness, badness, badness);
  check (24, true, NULL, NULL, NULL, badness, badness);
  check (25, true, NULL, NULL, NULL, NULL, badness);
  check (26, true, NULL, NULL, NULL, badness, NULL);
  check (27, true, NULL, NULL, badness, NULL, NULL);
  check (28, true, NULL, badness, NULL, NULL, NULL);
#else
# error
#endif
}]],[[1 OK
2 OK
3 OK
4 OK
5 OK
6 OK
7 OK
8 OK
9 OK
10 OK
11 OK
12 OK
13 OK
14 OK
15 OK
16 OK
17 OK
18 OK
19 OK
20 OK
21 OK
22 OK
23 OK
24 OK
25 OK
26 OK
27 OK
28 OK
]])
AT_CLEANUP

AT_SETUP([[_splitpath]])
AT_LIBI86_CHECK(dnl
[[#include <stdio.h>
#include <stdlib.h>
#include <libi86/stdlib.h>
#include <string.h>
static void
check (unsigned test_num, const char *path, const char *good_drv,
       const char *good_dir, const char *good_fname, const char *good_ext)
{
  char drv[_MAX_DRIVE], dir[_MAX_DIR], fname[_MAX_FNAME], ext[_MAX_EXT];
  memset (drv, 0xf6, sizeof drv);
  memset (dir, 0xf6, sizeof dir);
  memset (fname, 0xf6, sizeof fname);
  memset (ext, 0xf6, sizeof ext);
  _splitpath (path, drv, dir, fname, ext);
  if (strcasecmp (drv, good_drv) != 0
      || strcasecmp (dir, good_dir) != 0
      || strcasecmp (fname, good_fname) != 0
      || strcasecmp (ext, good_ext) != 0)
    abort ();
  printf ("%u OK\n", test_num);
}
int
main (void)
{
#ifdef __MSDOS__
  check (1,  "\\", "", "\\", "", "");
  check (2,  "/", "", "/", "", "");
  check (3,  "foo", "", "", "foo", "");
  check (4,  "Foo.", "", "", "foo", ".");
  check (5,  "foO.bAr", "", "", "foo", ".bar");
  check (6,  "/Foo.", "", "/", "foo", ".");
  check (7,  "\\foO.bAr", "", "\\", "foo", ".bar");
  check (8,  "foo.Bar/", "", "foo.bar/", "", "");
  check (9,  "foo.bar\\", "", "foo.bar\\", "", "");
  check (10, "/foo.Bar/", "", "/foo.bar/", "", "");
  check (11,  "\\foo.bar\\", "", "\\foo.bar\\", "", "");
  check (12, "foo.Bar/baz", "", "foo.bar/", "baz", "");
  check (13, "foo.bar\\BAZ", "", "foo.bar\\", "baz", "");
  check (14, "\\foo.Bar/ba?z", "", "\\foo.bar/", "ba?z", "");
  check (15, "/foo.bar\\BA?Z", "", "/foo.bar\\", "ba?z", "");
  check (16, "\\foo.Bar/*.*", "", "\\foo.bar/", "*", ".*");
  check (17, "/foo.bar\\*.*", "", "/foo.bar\\", "*", ".*");
  check (18, "\\foo/Bar/*.*", "", "\\foo/bar/", "*", ".*");
  check (19, "/foo\\bar\\*.*", "", "/foo\\bar\\", "*", ".*");
  check (20, "a:\\", "a:", "\\", "", "");
  check (21, "B:/", "b:", "/", "", "");
  check (22, "c:foo", "c:", "", "foo", "");
  check (23, "D:foo.baR", "d:", "", "foo", ".bar");
  check (24, "e:/foo", "e:", "/", "foo", "");
  check (25, "F:\\foo.baR", "f:", "\\", "foo", ".bar");
  check (26, "g:foo\\", "g:", "foo\\", "", "");
  check (27, "H:foo.baR/", "h:", "foo.bar/", "", "");
  check (28, "i:/foo\\", "i:", "/foo\\", "", "");
  check (29, "J:\\foo.baR/", "j:", "\\foo.bar/", "", "");
  check (30, "y:/foo\\bar/baz.qux\\quux*.q?uuux",
	     "y:", "/foo\\bar/baz.qux\\", "quux*", ".q?u");
  check (31, "quuuuuuuuuux", "", "", "quuuuuuu", "");
#else
# error
#endif
}]],[[1 OK
2 OK
3 OK
4 OK
5 OK
6 OK
7 OK
8 OK
9 OK
10 OK
11 OK
12 OK
13 OK
14 OK
15 OK
16 OK
17 OK
18 OK
19 OK
20 OK
21 OK
22 OK
23 OK
24 OK
25 OK
26 OK
27 OK
28 OK
29 OK
30 OK
31 OK
]])
AT_CLEANUP
