dnl Copyright (c) 2018 TK Chia
dnl
dnl This file is free software; you can redistribute it and/or modify it
dnl under the terms of the GNU Lesser General Public License as published by
dnl the Free Software Foundation; either version 2 of the License, or
dnl (at your option) any later version.
dnl
dnl This program is distributed in the hope that it will be useful, but
dnl WITHOUT ANY WARRANTY; without even the implied warranty of
dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
dnl Lesser General Public License for more details.
dnl
dnl You should have received a copy of the GNU Lesser General Public License
dnl along with this program; see the file COPYING2.LIB.  If not see
dnl <http://www.gnu.org/licenses/>.

AT_BANNER([[<bios.h> tests]])

AT_SETUP([[_bios_memsize]])
AT_LIBI86_CHECK_CXX(dnl
[[#include <stdlib.h>
#include <bios.h>
#ifndef __cplusplus
# error
#endif
int main (void)
{
  unsigned short kb = _bios_memsize (), kb2;
  __asm ("{movw %1:0x13, %0|mov %0, %1:0x13}"
	 : "=r" (kb2)
	 : "Q" (__builtin_ia16_selector (0x40)));
  if (kb != kb2)
    abort ();
  return 0;
}]],[])
AT_LIBI86_CHECK_FOR_NONDPMIABLE(dnl
[[#include <stdlib.h>
#include <bios.h>
static unsigned get_cs (void)
{
  unsigned v;
  __asm volatile ("{movw %%cs, %0|mov %0, cs}" : "=r" (v));
  return v;
}
static unsigned get_ss (void)
{
  unsigned v;
  __asm volatile ("{movw %%ss, %0|mov %0, ss}" : "=r" (v));
  return v;
}
int main (void)
{
  unsigned short kb = _bios_memsize ();
  if (kb != * (unsigned short __far *) 0x00400013ul)
    abort ();
  if (get_cs () >= 0x40u * kb)
    abort ();
  if (get_ss () >= 0x40u * kb)
    abort ();
  return 0;
}]],[])
AT_CLEANUP

AT_SETUP([[_bios_equiplist]])
AT_LIBI86_CHECK_FOR_NONDPMIABLE(dnl
[[#include <stdlib.h>
#include <bios.h>
int main (void)
{
  unsigned short hw = _bios_equiplist ();
  if (hw != * (unsigned short __far *) 0x00400010ul)
    abort ();
  return 0;
}]],[])
AT_CLEANUP

AT_SETUP([[_bios_keybrd]])
dnl FIXME: dosemu 1.4.0.8 with `-input ...' and a DPMI program crashes with
dnl "ERROR: do_call_back() executed within the signal context!", and it
dnl seems non-trivial to work around this problem.  For now, turn off the
dnl _bios_keybrd (.) tests that involve DPMI.  -- tkchia 20190519
AT_LIBI86_CHECK_CONSOLE_FOR_NONDPMIABLE(dnl
[[#include <stdlib.h>
#include <unistd.h>
#include <bios.h>
int main (void)
{
  if (_bios_keybrd (_KEYBRD_READ) != 0x3f00u)
    abort ();
  if (_bios_keybrd (_NKEYBRD_READ) != 0x4100u)
    abort ();
  while (! _bios_keybrd (_KEYBRD_READY));
  if (_bios_keybrd (_KEYBRD_READ) % 0x100u != (unsigned short) 'a')
    abort ();
  while (! _bios_keybrd (_NKEYBRD_READY));
  if (_bios_keybrd (_NKEYBRD_READ) % 0x100u != (unsigned short) 'A')
    abort ();
  if (_bios_keybrd (_NKEYBRD_READ) % 0x100u != (unsigned short) '!')
    abort ();
  if (_bios_keybrd (_KEYBRD_READ) != 0x2300u)
    abort ();
  if (_bios_keybrd (_KEYBRD_READY)
      || _bios_keybrd (_NKEYBRD_READY))
    abort ();
  return 0;
}]],[],[[-input '\p200;\F5;\F7;\p30;a\p30;A!\Ah']])
AT_CLEANUP

AT_SETUP([[_bios_disk]])
AT_LIBI86_CHECK_FOR_NONDPMIABLE(dnl
[[#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <bios.h>
#define BYTES_PER_SECT 0x200
#define EXTRA 0x40
int
main (void)
{
  static const unsigned char drives[] = { 0x00, 0x80, 0x01, 0x81 };
  static unsigned char buf1[BYTES_PER_SECT + EXTRA],
		       buf2[BYTES_PER_SECT + EXTRA];
  unsigned i, j, k;
  unsigned char status;
  struct diskinfo_t di;

  for (i = 0; i < sizeof drives; ++i)
    {
      unsigned char drive = drives[i];

      memset (&di, 0xf6, sizeof di);
      di.drive = drive;
      status = _bios_disk (_DISK_RESET, &di) >> 8;
      if (di.drive != drive)
	abort ();

#ifdef _LIBI86_INTERNAL_TEST_UNDERLYING
      /*
       * Enable this check only if we are trying to stress-test the
       * underlying DOS implementation or emulation.
       *
       * dosbox version 0.74-3 and dosemu 1.x do not implement int $0x13
       * function $0x01 correctly. :-(  QEMU with SeaBIOS does get it right,
       * though.  Recent versions of dosemu2 also have this fixed.
       *	-- tkchia 20201024
       */
      if (_bios_disk (_DISK_STATUS, &di) >> 8 != status)
	abort ();
#endif

      memset (buf1, 0x41, sizeof buf1);
      memset (buf2, 0xcc, sizeof buf2);
      di.head = di.track = 0;
      di.sector = di.nsectors = 1;
      di.buffer = buf1;
      j = 5;
      do
	{
	  status = _bios_disk (_DISK_READ, &di) >> 8;
	  if (di.drive != drive || di.head != 0 || di.track != 0
	      || di.sector != 1 || di.nsectors != 1
	      || di.buffer != (void __far *) buf1)
	    abort ();

	  for (k = 0; k < EXTRA; ++k)
	    if (buf1[BYTES_PER_SECT + k] != 0x41)
	      abort ();

	  if (status != 0)
	    _bios_disk (_DISK_RESET, &di);
	}
      while (--j != 0 && status != 0);
      if (status != 0)
	continue;

      di.buffer = buf2;
      j = 5;
      do
	{
	  status = _bios_disk (_DISK_READ, &di) >> 8;
	  if (di.drive != drive || di.head != 0 || di.track != 0
	      || di.sector != 1 || di.nsectors != 1
	      || di.buffer != (void __far *) buf2)
	    abort ();

	  for (k = 0; k < EXTRA; ++k)
	    if (buf2[BYTES_PER_SECT + k] != 0xcc)
	      abort ();

	  if (status != 0)
	    _bios_disk (_DISK_RESET, &di);
	}
      while (--j != 0 && status != 0);

      if (status != 0
	  || memcmp(buf1, buf2, BYTES_PER_SECT) != 0)
	abort ();
    }

  return 0;
}]],[])
AT_CLEANUP

AT_SETUP([[_bios_joystick]])
AT_LIBI86_CHECK(dnl
[[#include <stdlib.h>
#include <bios.h>
int main (void)
{
  unsigned short r1, r2;
  union _joyinfo_t info1, info2;
  unsigned i;
  for (i = 0; i < 0x100; ++i)
    {
      r1 = _bios_joystick (0, &info1);
      r2 = _bios_joystick (1, &info2);
      if ((r1 == 0) ^ (r2 == 0))
	abort ();
      if (r1 == 0 && r2 == 0)
	if (info2.pos.x_a == 0 && info2.pos.y_a == 0
	    && info2.pos.x_b == 0 && info2.pos.y_b == 0
	    && (info1.trig & 0xf0) != 0xf0)
	  abort ();
    }
  return 0;
}]],[])
AT_CLEANUP
