dnl Copyright (c) 2018 TK Chia
dnl
dnl This file is free software; you can redistribute it and/or modify it
dnl under the terms of the GNU Lesser General Public License as published by
dnl the Free Software Foundation; either version 3 of the License, or
dnl (at your option) any later version.
dnl
dnl This program is distributed in the hope that it will be useful, but
dnl WITHOUT ANY WARRANTY; without even the implied warranty of
dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
dnl Lesser General Public License for more details.
dnl
dnl You should have received a copy of the GNU Lesser General Public License
dnl along with this program; see the file COPYING3.LIB.  If not see
dnl <http://www.gnu.org/licenses/>.

AT_BANNER([[<bios.h> tests]])

AT_SETUP([[_bios_memsize]])
AT_LIBI86_CHECK(dnl
[[#include <stdlib.h>
#include <bios.h>
static unsigned get_cs (void)
{
  unsigned v;
  __asm volatile ("movw %%cs, %0" : "=r" (v));
  return v;
}
static unsigned get_ss (void)
{
  unsigned v;
  __asm volatile ("movw %%ss, %0" : "=r" (v));
  return v;
}
int main (void)
{
  unsigned short kb = _bios_memsize ();
  if (kb != * (unsigned short __far *) 0x00400013ul)
    abort ();
  if (get_cs () >= 0x40u * kb)
    abort ();
  if (get_ss () >= 0x40u * kb)
    abort ();
  return 0;
}]],[])
AT_CLEANUP

AT_SETUP([[_bios_equiplist]])
AT_LIBI86_CHECK(dnl
[[#include <stdlib.h>
#include <bios.h>
int main (void)
{
  unsigned short hw = _bios_equiplist ();
  if (hw != * (unsigned short __far *) 0x00400010ul)
    abort ();
  return 0;
}]],[])
AT_CLEANUP

AT_SETUP([[_bios_keybrd]])
dnl FIXME: dosemu 1.4.0.8 with `-input ...' and a DPMI program crashes with
dnl "ERROR: do_call_back() executed within the signal context!", and it
dnl seems non-trivial to work around this problem.  For now, turn off the
dnl _bios_keybrd (.) tests that involve DPMI.  -- tkchia 20190519
AT_LIBI86_CHECK_CONSOLE_FOR_NONDPMIABLE(dnl
[[#include <stdlib.h>
#include <unistd.h>
#include <bios.h>
int main (void)
{
  if (_bios_keybrd (_KEYBRD_READ) != 0x3f00u)
    abort ();
  if (_bios_keybrd (_NKEYBRD_READ) != 0x4100u)
    abort ();
  while (! _bios_keybrd (_KEYBRD_READY));
  if (_bios_keybrd (_KEYBRD_READ) % 0x100u != (unsigned short) 'a')
    abort ();
  while (! _bios_keybrd (_NKEYBRD_READY));
  if (_bios_keybrd (_NKEYBRD_READ) % 0x100u != (unsigned short) 'A')
    abort ();
  if (_bios_keybrd (_NKEYBRD_READ) % 0x100u != (unsigned short) '!')
    abort ();
  if (_bios_keybrd (_KEYBRD_READ) != 0x2300u)
    abort ();
  if (_bios_keybrd (_KEYBRD_READY)
      || _bios_keybrd (_NKEYBRD_READY))
    abort ();
  return 0;
}]],[],[[-input '\p20;\F5;\F7;\p30;a\p30;A!\Ah']])
AT_CLEANUP

AT_SETUP([[_bios_disk]])
AT_LIBI86_CHECK_FOR_NONDPMIABLE(dnl
[[#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <bios.h>
#define BYTES_PER_SECT 0x200
#define EXTRA 0x40
int
main (void)
{
  static const unsigned char drives[] = { 0x00, 0x80, 0x01, 0x81 };
  static unsigned char buf1[BYTES_PER_SECT + EXTRA],
		       buf2[BYTES_PER_SECT + EXTRA];
  unsigned i, j, k;
  unsigned char status;
  struct diskinfo_t di;

  for (i = 0; i < sizeof drives; ++i)
    {
      unsigned char drive = drives[i];

      memset (&di, 0xf6, sizeof di);
      di.drive = drive;
      status = _bios_disk (_DISK_RESET, &di) >> 8;
      if (di.drive != drive)
	abort ();

#if 0
      /* As of writing (20190608), neither DOSBox nor DOSEmu implements int
	 $0x13 function $0x01 correctly. :-(  QEMU with SeaBIOS does get it
	 right, though.  */
      if (_bios_disk (_DISK_STATUS, &di) >> 8 != status)
	abort ();
#endif

      memset (buf1, 0x41, sizeof buf1);
      memset (buf2, 0xcc, sizeof buf2);
      di.head = di.track = 0;
      di.sector = di.nsectors = 1;
      di.buffer = buf1;
      j = 5;
      do
	{
	  status = _bios_disk (_DISK_READ, &di) >> 8;
	  if (di.drive != drive || di.head != 0 || di.track != 0
	      || di.sector != 1 || di.nsectors != 1
	      || di.buffer != (void __far *) buf1)
	    abort ();

	  for (k = 0; k < EXTRA; ++k)
	    if (buf1[BYTES_PER_SECT + k] != 0x41)
	      abort ();

	  if (status != 0)
	    _bios_disk (_DISK_RESET, &di);
	}
      while (--j != 0 && status != 0);
      if (status != 0)
	continue;

      di.buffer = buf2;
      j = 5;
      do
	{
	  status = _bios_disk (_DISK_READ, &di) >> 8;
	  if (di.drive != drive || di.head != 0 || di.track != 0
	      || di.sector != 1 || di.nsectors != 1
	      || di.buffer != (void __far *) buf2)
	    abort ();

	  for (k = 0; k < EXTRA; ++k)
	    if (buf2[BYTES_PER_SECT + k] != 0xcc)
	      abort ();

	  if (status != 0)
	    _bios_disk (_DISK_RESET, &di);
	}
      while (--j != 0 && status != 0);

      if (status != 0
	  || memcmp(buf1, buf2, BYTES_PER_SECT) != 0)
	abort ();
    }

  return 0;
}]],[])
AT_CLEANUP
